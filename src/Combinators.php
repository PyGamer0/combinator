<?php

/**
 * For the full copyright and license information, please view
 * the LICENSE file that was distributed with this source code.
 */

declare(strict_types=1);

namespace loophp\combinator;

use Closure;
use loophp\combinator\Combinator\A;
use loophp\combinator\Combinator\B;
use loophp\combinator\Combinator\Blackbird;
use loophp\combinator\Combinator\C;
use loophp\combinator\Combinator\D;
use loophp\combinator\Combinator\E;
use loophp\combinator\Combinator\F;
use loophp\combinator\Combinator\G;
use loophp\combinator\Combinator\H;
use loophp\combinator\Combinator\I;
use loophp\combinator\Combinator\J;
use loophp\combinator\Combinator\K;
use loophp\combinator\Combinator\Ki;
use loophp\combinator\Combinator\L;
use loophp\combinator\Combinator\M;
use loophp\combinator\Combinator\O;
use loophp\combinator\Combinator\Omega;
use loophp\combinator\Combinator\Phoenix;
use loophp\combinator\Combinator\Psi;
use loophp\combinator\Combinator\Q;
use loophp\combinator\Combinator\R;
use loophp\combinator\Combinator\S;
use loophp\combinator\Combinator\S2;
use loophp\combinator\Combinator\S_;
use loophp\combinator\Combinator\T;
use loophp\combinator\Combinator\U;
use loophp\combinator\Combinator\V;
use loophp\combinator\Combinator\W;
use loophp\combinator\Combinator\Y;
use loophp\combinator\Combinator\Z;

/**
 * Class Combinators.
 *
 * phpcs:disable PSR1.Methods.CamelCapsMethodName.NotCamelCaps
 */
final class Combinators
{
    public static function A(): Closure
    {
        return A::of();
    }

    public static function B(): Closure
    {
        return B::of();
    }

    public static function Blackbird(): Closure
    {
        return Blackbird::of();
    }

    public static function C(): Closure
    {
        return C::of();
    }

    public static function D(): Closure
    {
        return D::of();
    }

    public static function E(): Closure
    {
        return E::of();
    }

    public static function F(): Closure
    {
        return F::of();
    }

    public static function G(): Closure
    {
        return G::of();
    }

    public static function H(): Closure
    {
        return H::of();
    }

    public static function I(): Closure
    {
        return I::of();
    }

    public static function J(): Closure
    {
        return J::of();
    }

    public static function K(): Closure
    {
        return K::of();
    }

    public static function Ki(): Closure
    {
        return Ki::of();
    }

    public static function L(): Closure
    {
        return L::of();
    }

    public static function M(): Closure
    {
        return M::of();
    }

    public static function O(): Closure
    {
        return O::of();
    }

    public static function Omega(): Closure
    {
        return Omega::of();
    }

    public static function Phoenix(): Closure
    {
        return Phoenix::of();
    }

    public static function Psi(): Closure
    {
        return Psi::of();
    }

    public static function Q(): Closure
    {
        return Q::of();
    }

    public static function R(): Closure
    {
        return R::of();
    }

    public static function S(): Closure
    {
        return S::of();
    }

    public static function S2(): Closure
    {
        return S2::of();
    }

    public static function S_(): Closure
    {
        return S_::of();
    }

    public static function T(): Closure
    {
        return T::of();
    }

    public static function U(): Closure
    {
        return U::of();
    }

    public static function V(): Closure
    {
        return V::of();
    }

    public static function W(): Closure
    {
        return W::of();
    }

    public static function Y(): Closure
    {
        return Y::of();
    }

    public static function Z(): Closure
    {
        return Z::of();
    }
}
